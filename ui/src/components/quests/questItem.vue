<template>
    <div>
        <h1 class="page-title">{{ heading }} a Quest!</h1>

        <b-alert dismissible v-model="showError" variant="danger"><p class="wrapWhiteSpace">{{errorMessage}}</p></b-alert>

        <b-alert dismissible v-model="showSuccessObjective" variant="success">{{successMessage}}</b-alert>

        <!-- Displays success alert and progress bar on quest creation as a loading bar
        for the quest being added to the database -->
        <b-alert
                :show="dismissCountDown"
                @dismiss-count-down="countDownChanged"
                @dismissed="dismissCountDown=0"
                dismissible
                variant="success">
            <p>Quest Successfully Saved</p>
            <b-progress
                    :max="dismissSecs"
                    :value="dismissCountDown - 1"
                    height="4px"
                    variant="success"
            ></b-progress>
        </b-alert>

        <!-- Confirmation modal for deleting a quest. -->
        <b-modal hide-footer id="editQuestModal" ref="editQuestModal" title="Edit Quest">
            <div v-if="activeUsers > 0"
                 class="d-block">
                This quest is used by {{activeUsers}} users.
            </div>
            <div class="d-block">
                Are you sure that you want to edit this Quest?
            </div>
            <b-row>
                <b-col cols="6">
                    <b-button
                            class="mr-2"
                            variant="warning"
                            @click="updateQuest"
                            block>
                        Edit
                    </b-button>
                </b-col>
                <b-col cols="6">
                    <b-button
                            @click="dismissModal('editQuestModal')"
                            class="mr-2"
                            block>
                        Cancel
                    </b-button>
                </b-col>
            </b-row>
        </b-modal>

        <b-row>
            <b-col>
                <b-form v-if="!editCurrentObjective  && !addNewObjective">

                    <b-container fluid>
                        <b-form-group
                                id="quest_title-field"
                                label="Quest Title:"
                                label-for="quest_title">
                            <b-form-textarea :type="'expandable-text'"
                                             id="quest_title"
                                             trim
                                             v-model="inputQuest.title"
                                             :state="validateTitle">
                            </b-form-textarea>
                        </b-form-group>
                    </b-container>
                    <b-form>
                        <b-container fluid>
                            <b-form-group
                                    id="startDate-field">
                                <b-row>
                                    <b-col cols="6">
                                        <label>Start Date:</label>
                                        <b-form-input :type="'date'"
                                                      id="startDate"
                                                      min='getCurrentDate()'
                                                      max='9999-12-31'
                                                      trim
                                                      v-model="inputQuest.startDate"
                                                      :state="validateStartDate">

                                        </b-form-input>
                                    </b-col>
                                    <b-col cols="6">
                                        <label>Start Time:</label>
                                        <b-form-input :type="'time'"
                                                      id="startTime"
                                                      min='getCurrentTime()'
                                                      max=''
                                                      trim
                                                      v-model="startTime"
                                                      :state="validateStartTime">
                                        </b-form-input>
                                    </b-col>
                                </b-row>
                            </b-form-group>
                            <b-form-group
                                    id="endDate-field">
                                <b-col cols="6"></b-col>
                                <b-col cols="6"></b-col>

                                <b-row>
                                    <b-col cols="6">
                                        <label>Expiration Date:</label>
                                        <b-form-input :type="'date'"
                                                      id="endDate"
                                                      min='getCurrentDate()'
                                                      max='9999-12-31'
                                                      trim
                                                      v-model="inputQuest.endDate"
                                                      :state="validateEndDate">

                                        </b-form-input>
                                    </b-col>

                                    <b-col cols="6">
                                        <label>Expiration Time:</label>
                                        <b-form-input :type="'time'"
                                                      id="endTime"
                                                      min='getCurrentTime()'
                                                      max=''
                                                      trim
                                                      v-model="endTime"
                                                      :state="validateEndTime">
                                        </b-form-input>
                                    </b-col>
                                </b-row>
                            </b-form-group>
                        </b-container>
                    </b-form>
                </b-form>

                <div v-if="!editCurrentObjective">
                    <b-row>
                        <b-col>
                            <b-button v-if="!addNewObjective" variant="success" :disabled="heading === 'Edit'"
                                      @click="showObjectiveComponent" block>
                                Add a new objective
                            </b-button>
                        </b-col>
                        <b-col>
                            <b-button v-if="!addNewObjective" variant="primary" :disabled="heading === 'Edit'"
                                      @click="showYourObjectivesComponent" block>
                                Select an objective
                            </b-button>
                        </b-col>
                    </b-row>
                </div>
                <b-row v-if="addNewObjective">
                    <b-col cols="12">
                        <b-card>
                            <add-objective
                                    :inputObjective="objectiveSelected"
                                    :profile="profile"
                                    :heading="'Add'"
                                    @addObjective="addObjective"
                                    @cancelCreate="cancelObjectiveCreate"
                                    @destination-select="$emit('destination-select')"
                                    :selectedDestination="destinationSelected">
                            </add-objective>
                        </b-card>
                    </b-col>
                </b-row>
                <b-row v-if="editCurrentObjective">
                    <b-col cols="12">
                        <b-card>
                            <add-objective
                                    :inputObjective="objectiveSelected"
                                    :profile="profile"
                                    :heading="'Edit'"
                                    @addObjective="addObjective"
                                    @editObjective="objectiveEdited"
                                    @cancelCreate="cancelObjectiveCreate"
                                    @destination-select="$emit('destination-select')"
                                    :selectedDestination="destinationSelected">
                            </add-objective>
                        </b-card>
                    </b-col>
                </b-row>

                <b-container fluid style="margin-top: 20px"
                             v-if="inputQuest.objectives.length > 0 && !editCurrentObjective">
                    <!-- Table displaying all quest objectives -->
                    <b-table :current-page="currentPage" :fields="fields" :items="inputQuest.objectives"
                             :per-page="perPage"
                             hover
                             id="myTrips"
                             outlined
                             ref="questObjective"
                             striped>

                        <!-- Buttons that appear for each objective added to table -->
                        <template v-slot:cell(actions)="row">
                            <b-button size="sm"
                                      @click="editObjective(row.item)"
                                      variant="warning"
                                      class="mr-2"
                                      block>Edit
                            </b-button>
                            <!--Removes objective from table-->
                            <b-button size="sm"
                                      @click="deleteObjective(row.item)"
                                      variant="danger"
                                      class="mr-2"
                                      :disabled="heading === 'Edit'"
                                      block>Delete
                            </b-button>
                            <b-button size="sm"
                                      v-if="heading === 'Edit'"
                                      @click="addHint(row.item)"
                                      variant="primary"
                                      class="mr-2"
                                      block>Add Hint
                            </b-button>
                        </template>

                        <!-- Buttons to shift objectives up/down in table -->
                        <template v-slot:cell(order)="row">
                            <b-button :disabled="inputQuest.objectives.length === 1 || row.index === 0 || heading === 'Edit'"
                                      @click="moveUp(row.index)"
                                      class="mr-2"
                                      size="sm"
                                      variant="success">&uarr;
                            </b-button>
                            <b-button :disabled="inputQuest.objectives.length === 1 ||
                           row.index === inputQuest.objectives.length-1 || heading === 'Edit'"
                                      @click="moveDown(row.index)"
                                      class="mr-2"
                                      size="sm"
                                      variant="success">&darr;
                            </b-button>
                        </template>
                        <template v-slot:cell(radius)="row">
                            {{getRadiusValue(row.item.radius)}}
                        </template>
                    </b-table>
                    <!-- Determines pagination and number of results per row of the table -->
                    <b-row>
                        <b-col cols="2">
                            <b-form-group
                                    id="numItems-field"
                                    label-for="perPage">
                                <b-form-select :options="optionViews"
                                               id="perPage"
                                               size="sm"
                                               trim v-model="perPage">
                                </b-form-select>
                            </b-form-group>
                        </b-col>
                        <b-col>
                            <b-pagination
                                    :per-page="perPage"
                                    :total-rows="rows"
                                    align="center"
                                    aria-controls="my-table"
                                    first-text="First"
                                    last-text="Last"
                                    size="sm"
                                    v-model="currentPage">
                            </b-pagination>
                        </b-col>
                    </b-row>
                </b-container>

                <b-row class="buttonMarginsTop" v-if="!editCurrentObjective && !addNewObjective">
                    <b-col>
                        <b-button @click="validateQuest" block variant="primary">
                            Save
                        </b-button>
                    </b-col>
                    <b-col>
                        <b-button @click="cancelCreate" block>
                            Cancel
                        </b-button>
                    </b-col>
                </b-row>
            </b-col>
        </b-row>

    </div>
</template>

<script>
    import AddObjective from "../objectives/objectiveItem";

    export default {
        name: "questItem",

        components: {
            AddObjective
        },

        props: {
            profile: Object,
            inputQuest: {
                default: function () {
                    return {
                        id: null,
                        title: "",
                        startDate: "",
                        endDate: "",
                        objectives: []
                    }
                }
            },
            newDestination: Object,
            selectedDestination: {
                default: function () {
                    return {}
                }
            },
            heading: String,
            selectedObjective: {
                default: function () {
                    return {}
                }
            }
        },

        data() {
            return {
                showError: false,
                showDateError: false,
                errorMessage: "",
                dismissSecs: 3,
                dismissCountDown: 0,
                savingObjective: false,
                letObjectiveSaved: false,
                startTime: "",
                endTime: "23:59",
                displayedDestination: null,
                addNewObjective: false,
                showSuccessObjective: false,
                successMessage: '',
                fields: [
                    'order',
                    {key: 'riddle', label: 'Riddle'},
                    {key: 'destination.name', label: 'Destination'},
                    {key: 'radius', label: 'Radius'},
                    'actions'
                ],
                optionViews: [
                    {value: 1, text: "1"},
                    {value: 5, text: "5"},
                    {value: 10, text: "10"},
                    {value: 15, text: "15"},
                    {value: Infinity, text: "All"}],
                perPage: 5,
                currentPage: 1,
                editCurrentObjective: false,
                objectiveIndex: 0,
                objectiveSelected: {
                    id: null,
                    destination: null,
                    riddle: "",
                    radius: null
                },
                destinationSelected: {},
                objectiveTemplate: {
                    id: null,
                    destination: null,
                    riddle: "",
                    radius: null
                },
                activeUsers: null,
                pointsRewarded: Number
            }
        },

        watch: {
            selectedDestination() {
                if (this.heading !== "Edit") {
                    this.destinationSelected = this.selectedDestination;
                    this.inputQuest.destination = this.selectedDestination;
                    this.displayedDestination = this.selectedDestination;
                }
            },

            selectedObjective() {
                if (this.heading !== "Edit") {
                    this.objectiveSelected = this.selectedObjective;
                }
            }
        },

        mounted() {
            this.splitDates();
            this.setDateTimeString();
        },

        computed: {
            /**
             * For new quest, checks the start date is after the current date.
             * For all other quests, checks the start date is either the same as or before the end date.
             *
             * @return {boolean} true if start date is valid, or a null if entry length isn't big enough.
             */
            validateStartDate() {
                // For a new hunt, the start date must be after today.
                if ((this.inputQuest.startDate < this.getDateString() && !this.inputQuest.id)) {
                    return false;
                }

                if(this.inputQuest.startDate.length < 6) {
                    return null;
                }

                // Otherwise, checks the start date is equal to or before the end date.
                return this.inputQuest.startDate <= this.inputQuest.endDate;
            },


            /**
             * Checks that the start time is not after or the same as the end time if the dates are the same,
             * and that the start time is not before the current time if the current date is today.
             *
             * @return {boolean} true if start time is valid, null if entry length isn't big enough.
             */
            validateStartTime() {
                // For new quests, check the start time is after the current time.
                if (this.startTime === "" || this.startTime === undefined) {
                    return false
                }
                if (this.inputQuest.startDate === this.inputQuest.endDate) {
                    if (this.startTime >= this.endTime) {
                        return false;
                    }
                }
                // If the dates are the same, check the start time is before the end time.
                if (this.inputQuest.startDate === this.inputQuest.endDate) {
                    if (this.startTime >= this.endTime) {
                        return false;
                    }
                }
                return true;
            },


            /**
             * Checks that the end time is not before or the same as the start time if the dates are the same.
             *
             * @return {boolean} true if end time is valid.
             */
            validateEndTime() {
                if (this.inputQuest.startDate === this.inputQuest.endDate) {
                    if (this.endTime <= this.startTime) {
                        return false;
                    }
                }
                return true;
            },


            /**
             * For new quests, checks the end date is after the current date.
             * For all other quests, checks the end date is either the same as or after the start date.
             *
             * @return {boolean} true if end date is valid.
             */
            validateEndDate() {
                // For a new quests, the end date must be after today.
                if (this.inputQuest.endDate < this.getDateString() && !this.inputQuest.id) {
                    return false;
                }
                if (this.inputQuest.endDate.length < 6) {
                    return null;
                }
                // Otherwise, checks the end date is equal to or after the start date.
                return this.inputQuest.endDate >= this.inputQuest.startDate;
            },


            /**
             * Returns true if the inputted title has length greater than 0.
             *
             * @return {Boolean} true if validated.
             */
            validateTitle() {
                if (this.inputQuest.title.length > 0) {
                    return true;
                } else if (this.inputQuest.title.length > 100) {
                    return false;
                }
                return null;
            },


            /**
             * Used to validate that there are enough objectives in the quest.
             *
             * @return {Boolean} true if validated.
             */
            validateObjectives() {
                if (this.inputQuest.objectives.length > 0) {
                    return true;
                }
            },


            /**
             * Computed function used for the pagination of the table.
             *
             * @return {number}    the number of rows required in the table based on number of objectives to be
             *                      displayed.
             */
            rows() {
                return this.inputQuest.objectives.length
            }
        },

        methods: {
            /**
             * Gets the current date+time as a Date object.
             *
             * @return Current Datetime.
             */
            getCurrentDate() {
                return new Date();
            },


            /**
             * sets the input values to be their proper string versions of current date/time.
             */
            setDateTimeString() {
                if (this.inputQuest.id === null) {
                    this.inputQuest.startDate = this.getDateString();
                    this.inputQuest.endDate = this.getDateString();
                    this.startTime = this.getTimeString();
                }
            },


            /**
             * Gets the current date as a string in YYYY-MM-DD format, including padding O's on month/day.
             *
             * @return Current Date in YYYY-MM-DD String Format.
             */
            getDateString() {
                let today = this.getCurrentDate();
                return today.getFullYear() + '-' +
                    ((today.getMonth() + 1) < 10 ? "0" : "")
                    + (today.getMonth() + 1) + '-' +
                    (today.getDate() < 10 ? "0" : "") +
                    today.getDate();
            },


            /**
             * Gets the current time as a string in HH:MM format, including padding O's.
             *
             * @return Current Time in HH:MM String Format.
             */
            getTimeString() {
                let today = this.getCurrentDate();
                return ((today.getHours()) < 10 ? "0" : "") +
                    today.getHours() + ":"
                    + ((today.getMinutes()) < 10 ? "0" : "") +
                    today.getMinutes();
            },


            /**
             * If all field validations pass on the active quest, saves the quest using either
             * updateQuest if there is an active editing ID or saveQuest otherwise (adding a new one).
             */
            validateQuest() {
                if (this.validateStartDate && this.validateStartTime && this.validateEndDate && this.validateEndTime
                    && this.validateTitle && this.validateObjectives) {
                    if (this.inputQuest.id !== null) {
                        this.getActiveUsers();
                        this.$refs['editQuestModal'].show()
                    } else {
                        this.saveQuest();
                    }
                } else if (!this.validateObjectives) {
                    this.errorMessage = "You must have at least 1 objective in the quest!";
                    this.showError = true;
                } else {
                    this.errorMessage = "Not all fields have valid information!";
                    this.showError = true;
                }

            },


            /**
             * Creates formatted Json of the currently active quest.
             */
            assembleQuest() {
                this.joinDates();
                for (let i = 0; i < this.inputQuest.objectives.length; i++) {
                    this.inputQuest.objectives[i].id = null;
                    this.inputQuest.objectives[i].destination = {
                        "id": this.inputQuest.objectives[i].destination.id,
                        "country": this.inputQuest.objectives[i].destination.country
                    };
                }
            },


            /**
             * POST's the currently active quest to the quests endpoint in Json format, for newly creating
             * quests.
             */
            saveQuest() {
                delete this.inputQuest.destination;
                this.assembleQuest();
                let self = this;
                fetch('/v1/quests/' + this.profile.id, {
                    method: 'POST',
                    headers: {'content-type': 'application/json'},
                    body: JSON.stringify(this.inputQuest)
                }).then(function (response) {
                    if (!response.ok) {
                        throw response;
                    } else {
                        return response.json();
                    }
                }).then(function (responseBody) {
                    self.showError = false;
                    self.$emit('successCreate', {message: "Quest Successfully Created", reward: responseBody.reward});
                    self.$emit('cancelCreate');
                }).catch(function (response) {
                    if (response.status > 404) {
                        self.showErrorToast([{message: "An unexpected error occurred"}]);
                    } else {
                        response.json().then(function(responseBody) {
                            self.showErrorToast(responseBody);
                        });
                    }
                });
            },


            /**
             * Gets all users that are currently using the given quest.
             *
             * @return {Promise <Response | never>}     the fetch method promise.
             */
            getActiveUsers() {
                let self = this;
                return fetch('/v1/quests/' + this.inputQuest.id + '/profiles', {
                    accept: "application/json"
                }).then(function (response) {
                    if (!response.ok) {
                        throw response;
                    } else {
                        return response.json();
                    }
                }).then(function (responseBody) {
                    self.showError = false;
                    self.activeUsers = responseBody.length;
                }).catch(function (response) {
                    if (response.status > 404) {
                        self.showErrorToast([{message: "An unexpected error occurred"}]);
                    } else {
                        response.json().then(function(responseBody) {
                            self.showErrorToast(responseBody);
                        });
                    }
                });
            },


            /**
             * PUT's the currently active quest to the quests endpoint in Json format, for edited
             * quests.
             */
            updateQuest() {
                delete this.inputQuest.owner;
                this.assembleQuest();
                let self = this;
                fetch('/v1/quests/' + this.inputQuest.id, {
                    method: 'PUT',
                    headers: {'content-type': 'application/json'},
                    body: JSON.stringify(this.inputQuest)
                }).then(function (response) {
                    if (!response.ok) {
                        throw response;
                    } else {
                        return response.json();
                    }
                }).then(function () {
                    self.showError = false;
                    self.$emit('successEdit', "Quest Successfully Edited");
                    self.$emit('cancelCreate')
                }).catch(function (response) {
                    self.splitDates();
                    if (response.status > 404) {
                        self.showErrorToast([{message: "An unexpected error occurred"}]);
                    } else {
                        response.json().then(function(responseBody) {
                            self.showErrorToast(responseBody);
                        });
                    }
                });
            },


            /**
             * Adds the specified objective to the list of quest objectives and handles the appropriate actions.
             */
            addObjective(objective) {
                this.inputQuest.objectives.push(JSON.parse(JSON.stringify(objective)));
                this.objectiveSelected = JSON.parse(JSON.stringify(this.objectiveTemplate));
                this.destinationSelected = {};
                this.successMessage = "Objective Successfully Added";
                this.showSuccessObjective = true;
                let self = this;
                setTimeout(function () {
                    self.showSuccessObjective = false;
                }, 3000);
                this.$emit('OBJ-side-bar', false)
            },


            /**
             * Replaces the objective in the quest objectives array with the newly edited objective.
             */
            objectiveEdited(objective) {
                this.inputQuest.objectives[this.objectiveIndex] = JSON.parse(JSON.stringify(objective));
                this.objectiveSelected = JSON.parse(JSON.stringify(this.objectiveTemplate));
                this.destinationSelected = {};
                this.successMessage = "Objective Successfully Edited";
                this.showSuccessObjective = true;
                let self = this;
                setTimeout(function () {
                    self.showSuccessObjective = false;
                }, 3000);
                this.$refs.questObjective.refresh();
            },


            /**
             * Displays the edit objective field and sets the current objective to the specified value.
             *
             * @param objective     the objective that is going to be edited.
             */
            editObjective(objective) {
                this.objectiveIndex = this.inputQuest.objectives.indexOf(objective);
                let radius = this.inputQuest.objectives[this.objectiveIndex].radius;
                let radiusValue;
                let radiusList = [
                    {value: 0.005, text: "5 m"},
                    {value: 0.01, text: "10 m"},
                    {value: 0.02, text: "20 m"},
                    {value: 0.03, text: "30 m"},
                    {value: 0.04, text: "40 m"},
                    {value: 0.05, text: "50 m"},
                    {value: 0.1, text: "100 m"},
                    {value: 0.25, text: "250 m"},
                    {value: 0.5, text: "500 m"},
                    {value: 1, text: "1 Km"},
                    {value: 2.5, text: "2.5 Km"},
                    {value: 5, text: "5 Km"},
                    {value: 7.5, text: "7.5 Km"},
                    {value: 10, text: "10 Km"},
                ];
                for (let i = 0; i < radiusList.length; i++) {
                    if (radius === radiusList[i].value) {
                        radiusValue = radiusList[i].value;
                    }
                }
                this.objectiveSelected = JSON.parse(JSON.stringify(this.inputQuest.objectives[this.objectiveIndex]));
                this.objectiveSelected.radius = radiusValue;
                this.destinationSelected = JSON.parse(JSON.stringify(this.inputQuest.objectives[this.objectiveIndex].destination));
                this.editCurrentObjective = true;
                if (this.heading !== "Edit") {
                    this.$emit('OBJ-side-bar', true);
                }
            },


            /**
             * Removes an objective from the list of quest's objectives.
             *
             * @param objective     the objective to be deleted.
             */
            deleteObjective(objective) {
                let rowIndex = this.inputQuest.objectives.indexOf(objective);
                this.inputQuest.objectives.splice(rowIndex, 1);
                this.showSuccessObjective = false;
                this.successMessage = "Objective Successfully Deleted";
                this.showSuccessObjective = true;
                let self = this;
                setTimeout(function () {
                    self.showSuccessObjective = false;
                }, 3000);
            },


            /**
             * Sends the emit to the quest list to view the add hint side bar
             */
            addHint(objective) {
                this.$emit('add-hint-side-bar', objective);
            },


            /**
             * Cancels the creation or editing of a quest by emitting a value to the questList.
             */
            cancelCreate() {
                this.$emit('cancelCreate');
            },


            /**
             * Cancels the current creation of an objective addition to a quest
             */
            cancelObjectiveCreate() {
                this.addNewObjective = false;
                this.editCurrentObjective = false;
                this.objectiveSelected = JSON.parse(JSON.stringify(this.objectiveTemplate));
                this.destinationSelected = {};
                this.$emit('clear-objective-values');
                this.$emit('OBJ-side-bar', false);
                this.$emit('Your-OBJ-side-bar', false);
            },


            /**
             * Splits the dates of the quest to put in the edit fields.
             */
            splitDates() {
                if (this.inputQuest.id !== null) {
                    this.inputQuest.startDate = new Date(this.inputQuest.startDate).toLocaleString('en-GB');
                    //Start date
                    let startDate = this.inputQuest.startDate;

                    // The date is the value before the comma
                    this.inputQuest.startDate = this.inputQuest.startDate.split(", ")[0];

                    // Change format of dates from the backslash symbol, reverse the order, and join with hyphens.
                    this.inputQuest.startDate = this.inputQuest.startDate.split("/").reverse().join("-");
                    this.startTime = startDate.split(" ")[1];

                    // Splits by either the + or the - symbol. Removing the timezone.
                    this.startTime = this.startTime.split("+")[0];
                    this.startTime = this.startTime.split("-")[0];

                    this.inputQuest.endDate = new Date(this.inputQuest.endDate).toLocaleString('en-GB');

                    //End Date
                    let endDate = this.inputQuest.endDate;

                    // The date is the values before the comma
                    this.inputQuest.endDate = this.inputQuest.endDate.split(", ")[0];

                    // Change format of dates from the backslash symbol, reverse the order, and join with hyphens.
                    this.inputQuest.endDate = this.inputQuest.endDate.split("/").reverse().join("-");
                    this.endTime = endDate.split(" ")[1];

                    // Splits by either the + or the - symbol. Removing the timezone.
                    this.endTime = this.endTime.split("+")[0];
                    this.endTime = this.endTime.split("-")[0];
                }
            },


            /**
             * Combines dates and times together from input fields and adds :00 on the end for seconds.
             */
            joinDates() {
                let timeOffset = this.formatOffset();

                if (this.startTime.length === 5) {
                    this.startTime += ":00";
                }

                if (this.endTime.length === 5) {
                    this.endTime += ":00";
                }

                this.inputQuest.startDate = this.inputQuest.startDate + " "
                    + this.startTime + timeOffset;

                this.inputQuest.endDate = this.inputQuest.endDate + " "
                    + this.endTime + timeOffset;

                delete this.inputQuest.startTime;
                delete this.inputQuest.endTime;
            },


            /**
             * Gets the local time offset and pads it to be 4 numbers long.
             */
            formatOffset() {
                let timeOffset = (Math.abs(new Date().getTimezoneOffset() / 60)).toString();

                let fullNumber = timeOffset.padStart(2, '0');
                fullNumber = fullNumber.padEnd(4, '0');

                let sign = (new Date().getTimezoneOffset() >= 0) ? "-" : "+";

                return sign + fullNumber;
            },


            /**
             * Used to dismiss the delete a quest confirmation modal.
             *
             * @param modal, the modal that is wanting to be dismissed.
             */
            dismissModal(modal) {
                this.$refs[modal].hide();
            },


            /**
             * Displays the countdown alert on the successful saving of a quest.
             */
            showAlert() {
                this.dismissCountDown = this.dismissSecs
            },


            /**
             * Used to allow an alert to countdown on the successful saving of a quest.
             *
             * @param dismissCountDown      the name of the alert.
             */
            countDownChanged(dismissCountDown) {
                this.dismissCountDown = dismissCountDown
            },


            /**
             * Used to move an objective in the table up one place.
             *
             * @param rowIndex      the row index of the objective in the table.
             */
            moveUp(rowIndex) {
                let upIndex = rowIndex - 1;
                let swapRow = this.inputQuest.objectives[rowIndex];
                this.inputQuest.objectives[rowIndex] = this.inputQuest.objectives[upIndex];
                this.inputQuest.objectives[upIndex] = swapRow;
                this.$refs.questObjective.refresh();
            },


            /**
             * Used to move an objective in the table down one place.
             *
             * @param rowIndex      the row index of the objective in the table.
             */
            moveDown(rowIndex) {
                let downIndex = rowIndex + 1;
                let swapRow = this.inputQuest.objectives[rowIndex];
                this.inputQuest.objectives[rowIndex] = this.inputQuest.objectives[downIndex];
                this.inputQuest.objectives[downIndex] = swapRow;
                this.$refs.questObjective.refresh();
            },


            /**
             * Displays the add objective component and the search destinations side bar.
             */
            showObjectiveComponent() {
                this.addNewObjective = !this.addNewObjective;
                this.$emit('OBJ-side-bar', true);
                this.$emit('Your-OBJ-side-bar', false);
            },


            /**
             * Displays the add objective component and the your objectives side bar.
             */
            showYourObjectivesComponent() {
                this.addNewObjective = !this.addNewObjective;
                this.$emit('Your-OBJ-side-bar', true);
                this.$emit('OBJ-side-bar', false);
            },


            /**
             * Returns a string radius value determined by the size.
             *
             * @param radius    the radius to be changed.
             */
            getRadiusValue(radius) {
                if (radius < 1) {
                    return radius * 1000 + " Meters"
                }
                return radius + " Km";
            }
        }
    }
</script>

